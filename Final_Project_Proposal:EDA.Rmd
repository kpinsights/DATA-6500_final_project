---
title: 'Interactive map'
knit: (function(input_file, encoding) {
    out_dir <- 'docs';
    rmarkdown::render(input_file,
      encoding=encoding,
      output_file=file.path(dirname(input_file), out_dir, 'index.html'))})
author: " "
date: ' '
output:
  html_document:
    fig_caption: true
urlcolor: blue
fontsize: 12pt
  
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = 'center')
```

```{r include=FALSE, echo=FALSE}
library(leaflet)
library(leaflet.providers)
library(dplyr)
library(terra)
library(osmdata)
library(sf)
library(googletraffic)
library(rmapshaper)
library(ggplot2)
library(tmap)
library(googleway)
library(lubridate)  
library(ggmap)     
library(raster)
library(tmaptools)
library(leaflet.extras)
library(webshot)
library(webshot2)
library(htmlwidgets)
library(gstat)
library(grid)
```


```{r Loading the datasets, message=FALSE, warning=FALSE, include=FALSE}
load("Final_Proj_data.RData")
```

```{r Toronto Center Boundary from OSM, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
bbox = st_bbox(c(xmin = -79.38884,
                 xmax = -79.34936,
                 ymax = 43.67320,
                 ymin = 43.64576), 
               crs = st_crs(4326))
wards = opq(bbox = bbox) |>
  add_osm_feature(key = "admin_level", value = "9") |>
  add_osm_feature(key = "boundary", value = "administrative") |>
  osmdata_sf()

toronto_center = wards$osm_multipolygons |>
  filter(osm_id == "9285661")

toronto_center_shp = "toronto_center_boundary.shp"
st_write(toronto_center, toronto_center_shp, append = FALSE)
toronto_center_traffic_polygon = st_read(toronto_center_shp)

```


```{r Toronto Bbox, message=FALSE, warning=FALSE, include=FALSE}
# Extracting bounding box coordinates for Toronto
toronto_bbox = getbb("Toronto, Ontario", format_out = "sf_polygon")
toronto_bbox_coords = st_bbox(toronto_bbox)
```

```{r Querying toronto border from OSM, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# Querying administrative boundaries of Toronto from OpenStreetMap
toronto_border = opq(toronto_bbox_coords) |>
  add_osm_feature(key = "boundary", value = "administrative") |>
  add_osm_feature(key = "admin_level", value = "6") |>
  osmdata_sf()

toronto_border = st_read("toronto_boundary.shp")
```

```{r Toronto Map for creating an inset}
## Querying toronto basemap from OSM
toronto_basemap = read_osm(toronto_bbox_coords, 
                           type = "esri-topo", 
                           mergeTiles = TRUE)

## Converting the basemap to spatraster 
toronto_raster = as(toronto_basemap, "SpatRaster") |> 
  project(crs(toronto_border)) |> #Projecting to CRS WGS84
  crop(toronto_border) |>  #Cropping to toronto border
  mask(toronto_border) #Masking 
```

```{r bbox of toronto centre ward}
# Getting bounding box of the Toronto Center polygon
tc_bbox = st_bbox(toronto_center_traffic_polygon)
```

```{r Toronto Centre Road Network from OSM, eval=FALSE, fig.cap="Plot showing road network within the Toronto Center boundary", message=FALSE, warning=FALSE, include=FALSE}
# Extracting roads from OSM
osm_road_data = opq(bbox = tc_bbox) |>
  add_osm_feature(key = 'highway') |>
  osmdata_sf()

# Extracting osm_lines (linestrings) for road network
road_network = osm_road_data$osm_lines

# Filtering road network to keep primary, 
#secondary, tertiary, and residential roads
relevant_road_types = c('primary', 'secondary', 'tertiary', 'residential')
filtered_road_network = road_network |>
  filter(highway %in% relevant_road_types)

# Cropping the road network within the Toronto Center boundary
cropped_road_network = filtered_road_network[
                                  toronto_center_traffic_polygon, , 
                                    op = st_within]
cropped_road_network = st_transform(cropped_road_network, 
                                    crs(toronto_center_traffic_polygon))
```

```{r ,include=FALSE}
# Plotting the main map (Toronto Center boundary with cropped road network)
main_map = tm_shape(toronto_center_traffic_polygon) +
  tm_borders(col = "black", lwd = 2) +
  tm_shape(cropped_road_network) +
  tm_lines(col = "red", lwd = 1) +
  tm_add_legend(type = "line", 
                labels = c("Road"), 
                col = c('red')) +
  tm_layout(frame = FALSE,
            legend.position = c(0.00,0.03),
            legend.bg.color = "white",
            legend.bg.alpha = 0.8,
            legend.text.size = 1,
            legend.frame = TRUE,
            legend.width = 0.4,
            legend.height = 0.3)

# Plotting the inset map (Toronto map with boundary of Toronto Center)
inset_map = tm_shape(toronto_raster) +
  tm_rgb() +
  tm_shape(toronto_center_traffic_polygon) +
  tm_borders(col = "red", lwd = 1) +
  tm_layout()

# Print both maps together
main_map
print(inset_map, vp = viewport(0.85, 0.85, width = 0.25, height = 0.30))

```


```{r Congestion Data from Google Traffic, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE, results='hide'}

google_key = Sys.getenv("google_maps_api_key")

#Creating the raster layer of traffic congestion
congestion_raster = gt_make_raster_from_polygon(polygon =
                                          toronto_center_traffic_polygon,
                                          zoom = 17,
                                          google_key = google_key,
                                          webshot_zoom = 2,
                                          webshot_delay = NULL,
                                          print_progress = TRUE)

# Converting raster layer into a dataframe
congestion_df = rasterToPoints(congestion_raster, spatial = TRUE) |>
    as.data.frame()

#Renaming the columns
names(congestion_df) = c( "congestion_level","x", "y")
```


```{r Rasterlayer to Spatraster and polygons, message=FALSE, warning=FALSE, include=FALSE}
congestion_spatraster = rast(congestion_raster) # Converting to spatraster
#Converting to polygons
congestion_polygons = as.polygons(congestion_spatraster, dissolve = TRUE)
```


```{r Reading traffic signal data, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
traffic_light_locations = read.csv("Traffic_lights.csv")
```

```{r Traffic Signal Location Data, message=FALSE, warning=FALSE}
traffic_lights_sf = st_as_sf(traffic_light_locations, 
                            coords = c("Longitude", "Latitude"),crs = 4326)
traffic_lights_toronto_center = traffic_lights_sf[
                                toronto_center_traffic_polygon, , 
                                op = st_within
                                ]
traffic_lights_toronto_center = traffic_lights_toronto_center |> 
  dplyr::select(geometry)
```


```{r Loading speed limits data, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
speed_limits = st_read("speed_limits.geojson")
```

```{r Speed Limits Data, message=FALSE, warning=FALSE}

speed_limits_filtered = speed_limits  |> 
  dplyr::select(maxspeed, geometry)

speed_limits_filtered_tc = speed_limits_filtered[
                            toronto_center_traffic_polygon, , 
                            op = st_within
                            ]

speed_limits_filtered_tc$maxspeed = as.numeric(
                                    speed_limits_filtered_tc$maxspeed
                                    )

```

```{r Ensuring same CRS of all elements, message=FALSE, warning=FALSE, include=FALSE}
toronto_center_traffic_polygon = st_transform(
                                toronto_center_traffic_polygon, 
                                4326
                                )
traffic_lights_toronto_center = st_transform(
                                traffic_lights_toronto_center, 
                                4326
                                )
speed_limits_filtered_tc = st_transform(
                                speed_limits_filtered_tc, 
                                4326
                                )
```

```{r Setting color palettes, message=FALSE, warning=FALSE}
#We first define the color palettes based on the values of 
#speed limit and congestion levels.

# Create color palette for speed limits
speed_limit_colors = c("#FF6347", "#FFD700", "#ADFF2F", 
                       "#32CD32", "#4682B4", "#1E90FF", "#00008B")
speed_palette = colorFactor(palette = speed_limit_colors, 
                            domain = speed_limits_filtered_tc$maxspeed)

# Create color palette for traffic congestion levels
congestion_pal = colorFactor(c("#228B22", "#FFA500", 
                               "#f00", "#100000"), 
                              values(congestion_spatraster), 
                              na.color = "transparent")
```

```{r Plotting traffic raster layer over a leaflet map, message=FALSE, warning=FALSE, results='hide'}

# Main map
leaflet_map <- leaflet(options = leafletOptions(width = "100%")) |>
  addProviderTiles("CartoDB.VoyagerLabelsUnder") |>
  addPolygons(data = toronto_center_traffic_polygon, 
              color = "black",
              weight = 4,  
              fillColor = "Transparent") |>
  addPolylines(data = speed_limits_filtered_tc, 
               color = ~speed_palette(maxspeed), 
               weight = 7, 
               opacity = 0.3,
               label = ~paste("Speed Limit: ", maxspeed, " km/h")) |>
  addPolygons(data = congestion_polygons, 
              color = ~congestion_pal(values(congestion_polygons)[,1]), 
              weight = 2,  
              fillOpacity = 1,
              label = ~paste("Congestion Level: ", 
                             values(congestion_polygons)[,1])) |>
  addCircleMarkers(data = traffic_lights_toronto_center, 
                   ~st_coordinates(geometry)[,1], 
                   ~st_coordinates(geometry)[,2],
                   color = "red", 
                   radius = 1, 
                   fillOpacity = 1,
                   label = "Traffic Signal") |>
  addLegend(pal = speed_palette, 
            values = speed_limits_filtered_tc$maxspeed, 
            title = "Speed Limits",
            position = "bottomleft") |>
  addLegend(pal = congestion_pal, 
            values = values(congestion_spatraster), 
            title = "Congestion Level",
            position = "bottomright") |>
  addLegend(colors = "red", 
            labels = "Traffic Signal", 
            title = "Traffic Signals",
            position = "topright") |>
  addFullscreenControl() |>
  addMiniMap(tiles = providers$CartoDB.Positron, 
             toggleDisplay = TRUE,
             minimized = FALSE)
```

```{r, fig.cap = "Interactive map showing the traffic congestion level, speed limits and traffic signal location within the Toronto Centre ward.", fig.align='center'}
leaflet_map
```

```{r Saving the datasets}
# datasets_to_save = list(
#   congestion_raster = congestion_raster,
#   traffic_light_locations = traffic_light_locations,
#   speed_limits = speed_limits,
#   toronto_border = toronto_border,
#   cropped_road_network = cropped_road_network,
#   toronto_center_traffic_polygon = toronto_center_traffic_polygon
# )
# 
# save_path = "Final_proj_data.RData"
# 
# save(list = names(datasets_to_save), file = save_path)
```

